这周学习了三种字符串算法

1: 字典树。
    该算法是完整匹配。用处是用于统计某个字符串出现多少次或者出现次数前50多的字符串。让我惊艳的地方在于

            if (!node[c]) {
                node[c] = Object.create(null)
            }
            node = node[c]

    子树的建立。一开始没看懂这里的写法，觉得这样不就都全都覆盖了么？后来反复看了好几遍才发现this.root的引用还是一直都在的。被覆盖只是node本身。node本身被子树覆盖，而这些子树的最终指向都是指向this.root的。所以才能构建整个树。

    后来我又发现其实直接用key-value也可以完成字典树的功能。只不过占的空间很大。字典树占的空间就小。

2: kmp
    这个算法是部分匹配。我在大学时期就已经接触过了。它的重点在于建立一个回溯数组，用于匹配的时候，如果匹配不到，就在匹配数组找当前字符要跳的地方。然后继续匹配。

3: wildcard
    这个算法是完全匹配。关键的地方在于星号的处理。首先第一个星号前面要完全匹配（包括？号）。然后遍历星号的个数（最后一个星号不遍历）。对星号后面的字符进行匹配。在这个阶段可以用正则也可以用kmp处理【？】的问题。用kmp的话就是找【？】前面的字符，进行匹配。匹配不到直接返回false。一直匹配完为止。最后就是匹配星号后的所有字符，从最后面开始匹配，因为是完全匹配，所以有一个不同都不行。

总计来说这些算法很巧妙、不复杂。但是如果单纯靠自己想出来的话又很难很难。。。
算法真是神奇。。。。